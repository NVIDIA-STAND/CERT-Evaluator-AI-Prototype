{
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473951": {
    "identified_severity": "High",
    "identified_priority": "P3",
    "explanation": "The function zng_tr_tally_dist writes to arrays s->d_buf and s->l_buf or s->sym_buf using the index s->sym_next, which is incremented after each write. There is a risk of overflow if s->sym_next reaches or exceeds the size of these arrays (s->sym_end). The function returns true if s->sym_next equals s->sym_end, but this check happens after the increment and write, so an out-of-bounds write can occur before the function signals the buffer is full. This is a real problem as it can lead to memory corruption and undefined behavior, classified as an overflowed array index read/write (CWE-125).",
    "fix_description": "Add a boundary check before writing to the arrays to ensure s->sym_next does not exceed s->sym_end. If the buffer is full, return true immediately without writing. This prevents out-of-bounds writes while preserving the function's behavior.",
    "patch": "--- a/deflate_p.h\n+++ b/deflate_p.h\n@@ static inline int zng_tr_tally_dist(deflate_state* s, uint32_t dist, uint32_t len) {\n-#ifdef LIT_MEM\n-    Assert(dist <= UINT16_MAX, \"dist should fit in uint16_t\");\n-    Assert(len <= UINT8_MAX, \"len should fit in uint8_t\");\n-    s->d_buf[s->sym_next] = (uint16_t)dist;\n-    s->l_buf[s->sym_next++] = (uint8_t)len;\n-#else\n-    s->sym_buf[s->sym_next++] = (uint8_t)(dist);\n-    s->sym_buf[s->sym_next++] = (uint8_t)(dist >> 8);\n-    s->sym_buf[s->sym_next++] = (uint8_t)len;\n-#endif\n-    s->matches++;\n-    dist--;\n-    Assert(dist < MAX_DIST(s) && (uint16_t)d_code(dist) < (uint16_t)D_CODES,\n-        \"zng_tr_tally: bad match\");\n-\n-    s->dyn_ltree[zng_length_code[len] + LITERALS + 1].Freq++;\n-    s->dyn_dtree[d_code(dist)].Freq++;\n-    return (s->sym_next == s->sym_end);\n+    if (s->sym_next >= s->sym_end) {\n+        return 1; // buffer full, do not write\n+    }\n+\n+#ifdef LIT_MEM\n+    Assert(dist <= UINT16_MAX, \"dist should fit in uint16_t\");\n+    Assert(len <= UINT8_MAX, \"len should fit in uint8_t\");\n+    s->d_buf[s->sym_next] = (uint16_t)dist;\n+    s->l_buf[s->sym_next++] = (uint8_t)len;\n+#else\n+    if (s->sym_next + 2 >= s->sym_end) {\n+        return 1; // buffer full, do not write\n+    }\n+    s->sym_buf[s->sym_next++] = (uint8_t)(dist);\n+    s->sym_buf[s->sym_next++] = (uint8_t)(dist >> 8);\n+    s->sym_buf[s->sym_next++] = (uint8_t)len;\n+#endif\n+\n+    s->matches++;\n+    dist--;\n+    Assert(dist < MAX_DIST(s) && (uint16_t)d_code(dist) < (uint16_t)D_CODES,\n+        \"zng_tr_tally: bad match\");\n+\n+    s->dyn_ltree[zng_length_code[len] + LITERALS + 1].Freq++;\n+    s->dyn_dtree[d_code(dist)].Freq++;\n+    return (s->sym_next == s->sym_end);\n }"
  },
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473947": {
    "identified_severity": "Medium",
    "identified_priority": "P7",
    "explanation": "The issue is an 'Overflowed constant' in the function crc32_braid at line 120, which corresponds to the assertion 'Assert(comb <= UINT32_MAX, \"comb should fit in uint32_t\")'. This assertion checks that the combined CRC value fits within a 32-bit unsigned integer. The concern is that the variable 'comb' might overflow the 32-bit range, which could lead to incorrect CRC calculations or undefined behavior. However, the code uses a 32-bit cast and a swap operation, and the assertion is meant to catch any overflow during development. The risk is medium because an overflow could cause incorrect CRC results, but the assertion helps detect this during testing. The fix should ensure that the assertion is valid and that the value does not overflow by adding a safe cast or limiting the operations to 32-bit values explicitly to prevent overflow.",
    "fix_description": "Add explicit casting to uint32_t for the intermediate calculations involving 'comb' to ensure no overflow occurs beyond 32 bits. This preserves behavior but prevents potential overflow issues that the assertion is meant to catch.",
    "patch": "--- a/arch/generic/crc32_braid_c.c\n+++ b/arch/generic/crc32_braid_c.c\n@@ ... @@\n-        comb = crc_word(crc0 ^ words[0]);\n-#if BRAID_N > 1\n-        comb = crc_word(crc1 ^ words[1] ^ comb);\n-#if BRAID_N > 2\n-        comb = crc_word(crc2 ^ words[2] ^ comb);\n-#if BRAID_N > 3\n-        comb = crc_word(crc3 ^ words[3] ^ comb);\n-#if BRAID_N > 4\n-        comb = crc_word(crc4 ^ words[4] ^ comb);\n-#if BRAID_N > 5\n-        comb = crc_word(crc5 ^ words[5] ^ comb);\n-#endif\n-#endif\n-#endif\n-#endif\n-#endif\n-        words += BRAID_N;\n-        Assert(comb <= UINT32_MAX, \"comb should fit in uint32_t\");\n-        c = (uint32_t)ZSWAPWORD(comb);\n+        comb = (uint32_t)crc_word(crc0 ^ words[0]);\n+#if BRAID_N > 1\n+        comb = (uint32_t)crc_word(crc1 ^ words[1] ^ comb);\n+#if BRAID_N > 2\n+        comb = (uint32_t)crc_word(crc2 ^ words[2] ^ comb);\n+#if BRAID_N > 3\n+        comb = (uint32_t)crc_word(crc3 ^ words[3] ^ comb);\n+#if BRAID_N > 4\n+        comb = (uint32_t)crc_word(crc4 ^ words[4] ^ comb);\n+#if BRAID_N > 5\n+        comb = (uint32_t)crc_word(crc5 ^ words[5] ^ comb);\n+#endif\n+#endif\n+#endif\n+#endif\n+#endif\n+        words += BRAID_N;\n+        Assert(comb <= UINT32_MAX, \"comb should fit in uint32_t\");\n+        c = (uint32_t)ZSWAPWORD(comb);\n"
  },
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473945": {
    "identified_severity": "Medium",
    "identified_priority": "P5",
    "explanation": "The Coverity finding reports an 'Overflowed constant' in the function crc32_fold_pclmulqdq at line 137. This function processes data in chunks and performs arithmetic on the length parameter 'len'. The potential overflow arises from calculations involving 'len' and pointer arithmetic, which could lead to integer overflow if 'len' is very large, causing buffer overflows or memory corruption. This is a real problem because it can lead to undefined behavior or security vulnerabilities when processing large inputs.",
    "fix_description": "To fix this, add a check to ensure that 'len' is within a safe range before performing arithmetic operations that could overflow. Specifically, limit 'len' to a maximum safe value before calculating alignment differences and processing data. This preserves behavior for normal inputs but prevents overflow on extreme inputs.",
    "patch": "--- a/arch/x86/crc32_fold_pclmulqdq_tpl.h\n+++ b/arch/x86/crc32_fold_pclmulqdq_tpl.h\n@@ -130,6 +130,11 @@\n-    algn_diff = ((uintptr_t)16 - ((uintptr_t)src & 0xF)) & 0xF;\n+    /* Prevent overflow in length calculations */\n+    if (len > SIZE_MAX - 16) {\n+        len = SIZE_MAX - 16;\n+    }\n+    algn_diff = ((uintptr_t)16 - ((uintptr_t)src & 0xF)) & 0xF;\n\n     if (algn_diff) {\n         xmm_crc_part = _mm_loadu_si128((__m128i *)src);\n"
  },
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473950": {
    "identified_severity": "Low",
    "identified_priority": "P2",
    "explanation": "Model returned non-JSON; raw output is placed in patch.",
    "fix_description": "N/A",
    "patch": "{\"identified_severity\":\"Medium\",\"identified_priority\":\"P6\",\"explanation\":\"The issue is an 'Overflowed constant' in the function crc32_fold_pclmulqdq_copy at line 137 in the file arch/x86/crc32_fold_pclmulqdq_tpl.h. The function processes data in chunks and uses size_t and pointer arithmetic for buffer handling. The overflow risk likely arises from the calculation of offsets or lengths when processing large input sizes, potentially causing integer overflow and leading to buffer overflows or memory corruption. This is a real problem because unchecked integer overflow can cause security vulnerabilities or crashes. The fix should ensure that all arithmetic involving lengths and offsets is done safely, with checks to prevent overflow or wraparound, preserving the behavior for valid inputs.\",\"fix_description\":\"Add explicit checks to ensure that length calculations and pointer arithmetic do not overflow. Specifically, ensure that the length 'len' and any derived values used for indexing or pointer arithmetic are within safe bounds before use. This can be done by adding boundary checks or using safe arithmetic functions. The patch below adds a check to prevent overflow in the calculation of 'algn_diff' and ensures that the length is safely handled before processing large blocks.\",\"patch\":\"--- a/arch/x86/crc32_fold_pclmulqdq_tpl.h\\n+++ b/arch/x86/crc32_fold_pclmulqdq_tpl.h\\n@@ -130,10 +130,16 @@\\n-    algn_diff = ((uintptr_t)16 - ((uintptr_t)src & 0xF)) & 0xF;\\n-    if (algn_diff) {\\n+    /* Calculate alignment difference safely to avoid overflow */\\n+    uintptr_t src_ptr = (uintptr_t)src;\\n+    algn_diff = ((uintptr_t)16 - (src_ptr & 0xF)) & 0xF;\\n+\\n+    /* Check that algn_diff does not exceed len to avoid overflow in pointer arithmetic */\\n+    if (algn_diff > len) {\\n+        algn_diff = len;\\n+    }\\n+\\n+    if (algn_diff) {\\n         xmm_crc_part = _mm_loadu_si128((__m128i *)src);\\n #ifdef COPY\\n         _mm_storeu_si128((__m128i *)dst, xmm_crc_part);\\n         dst += algn_diff;\\n-#else\\n-        XOR_INITIAL128(xmm_crc_part);\\n-\\n-        if (algn_diff < 4 && init_crc != 0) {\\n-            xmm_t0 = xmm_crc_part;\\n-            if (len >= 32) {\\n-                xmm_crc_part = _mm_loadu_si128((__m128i*)src + 1);\\n-                fold_1(&xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);\\n-                xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t0);\\n-            } else {\\n-                memcpy(partial_buf, src + 16, len - 16);\\n-                xmm_crc_part = _mm_load_si128((__m128i*)partial_buf);\\n-                fold_1(&xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);\\n-                xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t0);\\n-                src += 16;\\n-                len -= 16;\\n-#ifdef COPY\\n-                dst -= algn_diff;\\n-#endif\\n-                goto partial;\\n-            }\\n-\\n-            src += 16;\\n-            len -= 16;\\n-        }\\n-#endif\\n-\\n-        partial_fold(algn_diff, &xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3, &xmm_crc_part);\\n-\\n-        src += algn_diff;\\n-        len -= algn_diff;\\n-    }\\n+    } else {\\n+        XOR_INITIAL128(xmm_crc_part);\\n+\\n+        if (algn_diff < 4 && init_crc != 0) {\\n+            xmm_t0 = xmm_crc_part;\\n+            if (len >= 32) {\\n+                xmm_crc_part = _mm_loadu_si128((__m128i*)src + 1);\\n+                fold_1(&xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);\\n+                xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t0);\\n+            } else {\\n+                memcpy(partial_buf, src + 16, len - 16);\\n+                xmm_crc_part = _mm_load_si128((__m128i*)partial_buf);\\n+                fold_1(&xmm_crc0, &xmm_crc1, &xmm_crc2, &xmm_crc3);\\n+                xmm_crc3 = _mm_xor_si128(xmm_crc3, xmm_t0);\\n+                src += 16;\\n+                len -= 16;\\n+#ifdef COPY\\n+                dst -= algn_diff;\\n+#endif\\n+                goto partial;\\n+            }\\n+\\n+            src += 16;\\n+            len -= 16;\\n+        }\\n+    }\\n+\\n+    partial_fold(algn_diff, &xmm_crc0, &xmm_crc1, &x"
  },
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473948": {
    "identified_severity": "Medium",
    "identified_priority": "P5",
    "explanation": "The function CHUNKMEMSET performs memory copying with a distance parameter that is calculated as the absolute difference between two pointers (out and from). The variable 'dist' is a uint64_t holding the absolute distance. The function uses 'dist' in various calculations and comparisons, including as an argument to GET_CHUNK_MAG and in loops that decrement 'len'. The Coverity finding of 'Overflowed constant' in integer handling issues suggests that there might be a risk of integer overflow or wraparound in calculations involving 'dist' or related variables, especially when 'dist' is large or when 'len' is large. However, the code uses 'dist' carefully and the loops decrement 'len' accordingly. The main risk is if 'dist' is very large and causes unexpected behavior in the chunk loading or store operations, or if 'adv_amount' calculation leads to incorrect loop behavior. The code does not explicitly check for overflow conditions or validate 'dist' against 'len' beyond the initial memmove case. This could lead to potential overflow or out-of-bounds memory access in rare edge cases.",
    "fix_description": "Add a check to ensure that 'dist' does not exceed 'len' before proceeding with the chunk loading and storing logic. If 'dist' is greater than 'len', fallback to a safe memmove operation to avoid overflow and out-of-bounds memory access. This preserves the behavior but prevents the overflow issue.",
    "patch": "--- a/chunkset_tpl.h\n+++ b/chunkset_tpl.h\n@@ static inline uint8_t* CHUNKMEMSET(uint8_t *out, uint8_t *from, unsigned len) {\n-    uint64_t dist = llabs(sdist);\n+    uint64_t dist = llabs(sdist);\n+\n+    if (dist > len) {\n+        memmove(out, from, len);\n+        return out + len;\n+    }\n\n-    /* We are supporting the case for when we are reading bytes from ahead in the buffer.\n-     * We now have to handle this, though it wasn't _quite_ clear if this rare circumstance\n-     * always needed to be handled here or if we're just now seeing it because we are\n-     * dispatching to this function, more */\n-    if (sdist < 0 && dist < len) {\n+    /* We are supporting the case for when we are reading bytes from ahead in the buffer.\n+     * We now have to handle this, though it wasn't _quite_ clear if this rare circumstance\n+     * always needed to be handled here or if we're just now seeing it because we are\n+     * dispatching to this function, more */\n+    if (sdist < 0) {\n         #ifdef HAVE_MASKED_READWRITE\n-        /* We can still handle this case if we can mitigate over writing _and_ we\n-         * fit the entirety of the copy length with one load */\n-        if (len <= sizeof(chunk_t)) {\n-            /* Tempting to add a goto to the block below but hopefully most compilers\n-             * collapse these identical code segments as one label to jump to */\n-            return CHUNKCOPY(out, from, len);\n-        }\n-        #endif\n-        /* Here the memmove semantics match perfectly, as when this happens we are\n-         * effectively sliding down the contents of memory by dist bytes */\n-        memmove(out, from, len);\n-        return out + len;\n-    }\n+        /* We can still handle this case if we can mitigate over writing _and_ we\n+         * fit the entirety of the copy length with one load */\n+        if (len <= sizeof(chunk_t)) {\n+            /* Tempting to add a goto to the block below but hopefully most compilers\n+             * collapse these identical code segments as one label to jump to */\n+            return CHUNKCOPY(out, from, len);\n+        }\n+        #endif\n+        /* Here the memmove semantics match perfectly, as when this happens we are\n+         * effectively sliding down the contents of memory by dist bytes */\n+        memmove(out, from, len);\n+        return out + len;\n+    }\n "
  },
  "zlib-ng/zlib-ng:287c4dce22a3244a0e2602d9e5bf0929df74fd27:CID=473946": {
    "identified_severity": "Medium",
    "identified_priority": "P5",
    "explanation": "The function CHUNKMEMSET performs memory copying with a distance 'dist' calculated as the absolute difference between pointers 'out' and 'from'. The variable 'len' is an unsigned integer representing the length of bytes to copy. The issue is an integer overflow risk when 'len' is large and combined with the arithmetic operations involving 'adv_amount' and 'len' in the loops. Specifically, the subtraction 'len -= 2 * adv_amount' and 'len -= adv_amount' can underflow if 'len' is smaller than the subtracted value, causing an overflow in unsigned arithmetic. This can lead to buffer overflows or memory corruption. The code assumes 'len' is large enough, but this is not explicitly checked, so the overflow is a real problem in this context.",
    "fix_description": "Add explicit checks to ensure that 'len' is large enough before performing the subtractions in the loops to prevent unsigned integer underflow. This can be done by changing the loop conditions to ensure 'len' is at least the amount to be subtracted before each iteration.",
    "patch": "--- a/chunkset_tpl.h\n+++ b/chunkset_tpl.h\n@@ static inline uint8_t* CHUNKMEMSET(uint8_t *out, uint8_t *from, unsigned len) {\n-    while (len >= (2 * sizeof(chunk_t))) {\n+    while (len >= (2 * sizeof(chunk_t)) && len >= 2 * adv_amount) {\n         storechunk(out, &chunk_load);\n         storechunk(out + adv_amount, &chunk_load);\n         out += 2 * adv_amount;\n-        len -= 2 * adv_amount;\n+        len -= 2 * adv_amount;\n     }\n \n-    while (len >= sizeof(chunk_t)) {\n+    while (len >= sizeof(chunk_t) && len >= adv_amount) {\n         storechunk(out, &chunk_load);\n-        len -= adv_amount;\n+        len -= adv_amount;\n         out += adv_amount;\n     }\n "
  }
}